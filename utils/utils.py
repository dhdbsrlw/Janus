import random
import numpy as np
import torch
import os
import time
import math
import json
import base64

class AttrDict(dict):
    __setattr__ = dict.__setitem__

    def __getattribute__(self, item):
        if item in self:
            return self[item]
        else:
            return super().__getattribute__(item)

    @classmethod
    def from_nested_dicts(cls, data):
        if not isinstance(data, dict):
            return data
        else:
            return cls({key: cls.from_nested_dicts(data[key]) for key in data})


def get_parameter_names(model, forbidden_layer_types):
    """
    Returns the names of the model parameters that are not inside a forbidden layer.
    """
    result = []
    for name, child in model.named_children():
        result += [
            f"{name}.{n}"
            for n in get_parameter_names(child, forbidden_layer_types)
            if not isinstance(child, tuple(forbidden_layer_types))
        ]
    # Add model specific parameters (defined with nn.Parameter) since they are not in any child.
    result += list(model._parameters.keys())
    return result


def append_to_json(file_path, data):
    if os.path.exists(file_path):
        with open(file_path, 'r+') as f:
            existing_data = json.load(f)
            if isinstance(existing_data, list):
                existing_data.append(data)
            else:
                existing_data = [existing_data, data]
            f.seek(0)
            json.dump(existing_data, f, indent=4)
    else:
        with open(file_path, 'w') as f:
            json.dump([data], f, indent=4)


def write_json_data(file, data, is_first_element):
    """Writes a single JSON object to the file with proper formatting."""
    json_string = json.dumps(data, indent=4)
    if not is_first_element:
        file.write(",\n")
    else:
        is_first_element = False
    file.write(json_string)
    return is_first_element


def encode_image(image_path):
    with open(image_path, "rb") as image_file:
        return base64.b64encode(image_file.read()).decode('utf-8')


def listdir(path):
    return [f for f in os.listdir(path) if not f.startswith(".")]

def avg_std(data: list) -> tuple:
    avg = sum(data) / len(data)
    if len(data) == 1:
        std = 0.0
    else:
        std = math.sqrt(sum([(x - avg) ** 2 for x in data]) / (len(data) - 1))
    return round(avg, 3), round(std, 3)

def set_seed(seed):
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)


def pytorch_worker_info(group=None):
    """Return node and worker info for PyTorch and some distributed environments."""
    rank = 0
    world_size = 1
    worker = 0
    num_workers = 1
    if "RANK" in os.environ and "WORLD_SIZE" in os.environ:
        rank = int(os.environ["RANK"])
        world_size = int(os.environ["WORLD_SIZE"])
    else:
        try:
            import torch.distributed

            if torch.distributed.is_available() and torch.distributed.is_initialized():
                group = group or torch.distributed.group.WORLD
                rank = torch.distributed.get_rank(group=group)
                world_size = torch.distributed.get_world_size(group=group)
        except ModuleNotFoundError:
            pass
    if "WORKER" in os.environ and "NUM_WORKERS" in os.environ:
        worker = int(os.environ["WORKER"])
        num_workers = int(os.environ["NUM_WORKERS"])
    else:
        try:
            import torch.utils.data

            worker_info = torch.utils.data.get_worker_info()
            if worker_info is not None:
                worker = worker_info.id
                num_workers = worker_info.num_workers
        except ModuleNotFoundError:
            pass

    return rank, world_size, worker, num_workers

def pytorch_worker_seed(group=None):
    """Compute a distinct, deterministic RNG seed for each worker and node."""
    rank, world_size, worker, num_workers = pytorch_worker_info(group=group)
    return rank * 1000 + worker


def make_seed(*args):
    """
    Generate a seed value based on the hashed values of input arguments.

    This function takes any number of arguments, hashes each argument, and combines them into a single seed value.
    The seed is generated by iteratively multiplying the current seed by 31, adding the hash of the next argument,
    and taking the result modulo 2^31. This ensures the seed stays within the range of a 32-bit integer.

    Args:
        *args: Variable length argument list to be hashed and combined.

    Returns:
        int: The final seed value.
    """
    seed = 0
    for arg in args:
        seed = (seed * 31 + hash(arg)) & 0x7FFFFFFF
    return seed


def truly_random_seed(*args):
    """
    Generate a truly random seed value.

    This function generates a seed value that is as random as possible by using the current process ID, the current
    nanosecond timestamp, and a random 4-byte string generated by the OS, whose randomness comes from the random number
    generator provided by the operating system. These values are passed to the make_seed function to generate the final
    seed value.

    Returns:
        int: A truly random seed value.
    """
    return make_seed(pytorch_worker_seed(), os.getpid(), time.time_ns(), os.urandom(4), *args)